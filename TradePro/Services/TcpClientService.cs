using System;
using System.Buffers.Binary;
using System.Net.Sockets;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using System.Net.Security;

namespace TradePro.Services
{
    public record LoginResponseDto(string Username, decimal Balance, int UserId);
    public record RegisterResponseDto(string Message);
    public record ErrorResponseDto(string Error, string Message);
    public record MarketDto(string Symbol, decimal Price, double Change, bool IsUp);

    // Minimal TCP client to request simple JSON actions from server, secured with TLS (SslStream).
    // Matches server framing: 4-byte big-endian length then UTF8 JSON payload.
    public class TcpClientService : IDisposable
    {
        private readonly string _host;
        private readonly int _port;
        private TcpClient? _client;
        private Stream? _stream; // will be SslStream after auth
        private bool _disposed;

        private readonly string _serverCertPath;

        public TcpClientService(string host = "127.0.0.1", int port = 6000)
        {
            _host = host;
            _port = port;
            // Expect server public cert next to executable (generated by server in its base dir)
            _serverCertPath = Path.Combine(AppContext.BaseDirectory, "cert.cer");
        }

        public async Task ConnectAsync(CancellationToken ct = default)
        {
            if (_client != null && _client.Connected && _stream != null) return;
            _client = new TcpClient();
            await _client.ConnectAsync(_host, _port, ct).ConfigureAwait(false);
            var netStream = _client.GetStream();

            // Create SslStream that validates server certificate matches cert.cer
            var ssl = new SslStream(netStream, leaveInnerStreamOpen: false, new RemoteCertificateValidationCallback(ValidateServerCertificate));

            var sslOptions = new SslClientAuthenticationOptions
            {
                TargetHost = "TradeProLocal", // must match server CN
                EnabledSslProtocols = System.Security.Authentication.SslProtocols.Tls12 | System.Security.Authentication.SslProtocols.Tls13,
                CertificateRevocationCheckMode = X509RevocationMode.NoCheck
            };

            await ssl.AuthenticateAsClientAsync(sslOptions, ct).ConfigureAwait(false);
            _stream = ssl;
        }

        private bool ValidateServerCertificate(object? sender, X509Certificate? certificate, X509Chain? chain, SslPolicyErrors sslPolicyErrors)
        {
            try
            {
                if (!File.Exists(_serverCertPath))
                {
                    // If we don't have the cert to compare, fall back to default validation
                    return sslPolicyErrors == SslPolicyErrors.None;
                }

                var expected = new X509Certificate2(File.ReadAllBytes(_serverCertPath));
                if (certificate == null) return false;
                var actual = new X509Certificate2(certificate);
                // Compare thumbprints (case-insensitive)
                return string.Equals(expected.Thumbprint, actual.Thumbprint, StringComparison.OrdinalIgnoreCase);
            }
            catch
            {
                return false;
            }
        }

        public async Task<T?> SendRequestAsync<T>(object request, CancellationToken ct = default)
        {
            if (_disposed) throw new ObjectDisposedException(nameof(TcpClientService));
            if (_client == null || !_client.Connected || _stream == null) await ConnectAsync(ct);
            if (_stream == null) throw new InvalidOperationException("Network stream not available");

            var reqBytes = JsonSerializer.SerializeToUtf8Bytes(request);
            var len = new byte[4];
            BinaryPrimitives.WriteInt32BigEndian(len, reqBytes.Length);
            await _stream.WriteAsync(len, 0, len.Length, ct).ConfigureAwait(false);
            await _stream.WriteAsync(reqBytes, 0, reqBytes.Length, ct).ConfigureAwait(false);
            await _stream.FlushAsync(ct).ConfigureAwait(false);

            // read 4-byte response length
            var lenBuf = new byte[4];
            if (!await ReadExactAsync(_stream, lenBuf, 0, 4, ct).ConfigureAwait(false)) throw new IOException("Remote closed");
            int respLen = BinaryPrimitives.ReadInt32BigEndian(lenBuf);
            var buf = new byte[respLen];
            if (!await ReadExactAsync(_stream, buf, 0, respLen, ct).ConfigureAwait(false)) throw new IOException("Remote closed");

            var el = JsonSerializer.Deserialize<T>(buf, new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
            return el;
        }

        public async Task<LoginResponseDto?> SendLoginAsync(string username, string password, CancellationToken ct = default)
        {
            var req = new { action = "login", username = username, password = password };
            var raw = await SendRequestAsync<JsonElement>(req, ct).ConfigureAwait(false);
            if (raw.ValueKind == JsonValueKind.Object)
            {
                if (raw.TryGetProperty("error", out _))
                {
                    return null;
                }

                try
                {
                    var dto = JsonSerializer.Deserialize<LoginResponseDto>(raw.GetRawText(), new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    return dto;
                }
                catch { return null; }
            }
            return null;
        }

        public async Task<RegisterResponseDto?> SendRegisterAsync(string username, string password, CancellationToken ct = default)
        {
            var req = new { action = "register", username = username, password = password };
            var raw = await SendRequestAsync<JsonElement>(req, ct).ConfigureAwait(false);
            if (raw.ValueKind == JsonValueKind.Object)
            {
                if (raw.TryGetProperty("error", out _))
                {
                    return null;
                }

                try
                {
                    var dto = JsonSerializer.Deserialize<RegisterResponseDto>(raw.GetRawText(), new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    return dto;
                }
                catch { return null; }
            }
            return null;
        }

        public async Task<List<MarketDto>?> GetMarketsAsync(CancellationToken ct = default)
        {
            var req = new { action = "get_markets" };
            return await SendRequestAsync<List<MarketDto>>(req, ct).ConfigureAwait(false);
        }

        private static async Task<bool> ReadExactAsync(Stream stream, byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            int read = 0;
            while (read < count)
            {
                int r;
                try
                {
                    r = await stream.ReadAsync(buffer, offset + read, count - read, cancellationToken).ConfigureAwait(false);
                }
                catch
                {
                    return false;
                }
                if (r == 0) return false;
                read += r;
            }
            return true;
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;
            try { _stream?.Close(); } catch { }
            try { _client?.Close(); } catch { }
        }
    }
}
